---
title: "Exploring Data in R"
author: "Christopher Prener"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Once data have been corrected using `driftR`, `R` provides a host of tools for exploring them. This article will quickly cover a few techniques for both doing exploratory data analysis using [`ggplot2`] and obtaining some basic descriptive statistics. This article assumes you've completed the cleaning of the example data included in this package (see the "Getting Started" vignette).

## Packages

The packages that we'll use, beyond the `base` package, are all a core part of the [`tidyverse`](https://www.tidyverse.org):

* [`ggplot2`](http://ggplot2.tidyverse.org) - a set of tools for implementing the [Grammar of Graphics](http://vita.had.co.nz/papers/layered-grammar.pdf)
* [`dplyr`](http://dplyr.tidyverse.org) - a set of common verbs for cleaning and wrangling data
* [`tidyr`](http://tidyr.tidyverse.org) - functions for consistently tidying data so that "(1) each variable is in a column, (2) each observation is in a row, and (3) each value is a cell"
* [`stringr`](http://stringr.tidyverse.org) - a set of functions for manipulating string (text) data

## Descriptive Statistics

The `base` package, which is part of the "base" `R` distribution that users typically download from CRAN or one of its mirrors, can be used for obtaining basic descriptive statistics. In particular, the `summary()` function provides a number of useful statistics including range, median, and mean:

```{r, eval=FALSE}
> summary(df$SpCond)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.7450  0.7520  0.7670  0.7719  0.7900  0.8180 
> summary(df$SpCond_Corr)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.7495  0.7677  0.8018  0.8067  0.8422  0.8872 
```

## Exploratory Data Analysis

[Exploratory data analysis](https://en.wikipedia.org/wiki/Exploratory_data_analysis) (EDA) is a set of techniques promoted by [John Tukey](https://en.wikipedia.org/wiki/John_Tukey) for visually assessing data sets. `ggplot2` and the tidyverse make it easy to conduct EDA on your data. You'll need to have each of the packages above loaded in your `R` session:

```{r, eval=FALSE}
library(ggplot2)  # data visualization
library(scales)   # date/time scales for plots

library(dplyr)    # data wrangling
library(tidyr)    # reshaping data
library(stringr)  # tools for strings
```

### Histograms

Histograms are a classic way to assess the shape of the distribution of a single variable. They also make for an easy introduction to `ggplot2`. Every `ggplot2` call has at least two components - an initial `ggplot()` function and a "geom" that defines the way the underlying data are transformed for plotting purposes:

```{r, eval=FALSE}
ggplot(data = df) +
  geom_histogram(mapping = aes(x = pH), bins = 10)
```

We assign the *data source* in `ggplot()`, and describe the *aesthetic mapping* (the connection of data to visual properties) in the `geom_histogram()` call. The code shown above will produce this plot:

![](pH_hist.png)

### Visualizing Drift Over Time

The key feature of `driftR` is the correction of drift that occurs over time. We can visualize this change in our data with a few additional steps. Before we create the plot, we need a variable that combines our `Date` and `Time` data created by `dr_readSonde()`. We need to concatenate these two variables togther using `str_c()`, and then store them as properly identified date-time data (which `R` calls `POSIXct`) using `as.POSIXct()`. These changes are both made using the [`mutate()`](http://dplyr.tidyverse.org/reference/mutate.html) function from [`dplyr`](http://dplyr.tidyverse.org), which allows us to create new variables. Once we have a date-time variable, we can use it as the `x` variable on our plot and plot a measure like specific conductance (`SpCond`) against it:

```{r, eval=FALSE}
df %>%
  mutate(dateTime = str_c(Date, Time, sep = " ", collapse = NULL)) %>%
  mutate(dateTime = as.POSIXct(dateTime, format = "%m/%d/%Y %H:%M:%S")) %>%
  ggplot() +
    geom_line(mapping = aes(x = dateTime, y = SpCond))
```

This code is an example of piping, a technique that is described in our article on [tidy evaluation](TidyEval.html). Note that we did not need to reference the data source in the initial `ggplot()` call - this is "passed" through the piped code. It will produce the following plot:

![](SpCond_line.png)

This code should be portable from session to session with little modification (you'll have to change the dataframe name if you use something other than `df`).

### Comparing Corrected and Uncorrected Data 

`driftR` produces "wide" data, where each row is a single observation taken by the instrument and each column represents a measurement of a particular characteristic. If we want to compare two characteristics on a plot, like the corrected and uncorrected versions of specific conductance, we need to convert our data to long using the [`gather()`](http://tidyr.tidyverse.org/reference/gather.html) function from the [`tidyr`](http://tidyr.tidyverse.org) package. This conversion is done only on the variables we are interested in (our `dateTime` measure plus `SpCond` and `SpCond_Corr`). 

The following code: 

* takes the initial `df` data, then
* creates our date-time measure as before, uses the [`select()`](http://dplyr.tidyverse.org/reference/select.html) function to retain only the variables of interest, then
* converts them to wide to long with a new variable `measure` containing an indicator of whether the data are corrected or not and a new variable `value` containing the actual measured (or corrected) value, then
* re-orders the variables so that each date-time pair are in contiguous rows:

```{r, eval=FALSE}
> df %>%
+     mutate(dateTime = str_c(Date, Time, sep = " ", collapse = NULL)) %>%
+     mutate(dateTime = as.POSIXct(dateTime, format = "%m/%d/%Y %H:%M:%S")) %>%
+     select(dateTime, SpCond, SpCond_Corr) %>%
+     gather(key = "measure", value = "value", SpCond, SpCond_Corr) %>%
+     arrange(dateTime)
# A tibble: 3,024 x 3
              dateTime     measure     value
                <dttm>       <chr>     <dbl>
 1 2015-09-18 13:00:52      SpCond 0.7490000
 2 2015-09-18 13:00:52 SpCond_Corr 0.7494559
 3 2015-09-18 13:05:52      SpCond 0.7490000
 4 2015-09-18 13:05:52 SpCond_Corr 0.7495014
 5 2015-09-18 13:10:52      SpCond 0.7500000
 6 2015-09-18 13:10:52 SpCond_Corr 0.7505470
 7 2015-09-18 13:15:52      SpCond 0.7500000
 8 2015-09-18 13:15:52 SpCond_Corr 0.7505925
 9 2015-09-18 13:20:51      SpCond 0.7500000
10 2015-09-18 13:20:51 SpCond_Corr 0.7506379
# ... with 3,014 more rows
```

You'll notice that each date-time point now has two rows, one for `SpCond` and one for `SpCond_Corr`. This is the hallmark of "long" formatted data.

We can extend this example by adding a `ggplot()` call to use the "long" data to plot the difference between the corrected and uncorrected values. We've omitted the `arrange()` function here because it does not have a practicel impact on how our data are plotted.

```{r, eval=FALSE}
df %>%
  mutate(dateTime = str_c(Date, Time, sep = " ", collapse = NULL)) %>%
  mutate(dateTime = as.POSIXct(dateTime, format = "%m/%d/%Y %H:%M:%S")) %>%
  select(dateTime, SpCond, SpCond_Corr) %>%
  gather(key = "measure", value = "value", SpCond, SpCond_Corr) %>%
  ggplot() +
    geom_line(mapping = aes(x = dateTime, y = value, group = measure, color = measure))
```

The `group` argument in the aesthetic mapping ensures that our data are split by whether they are the raw `SpCond` values or the corrected `SpCond_Corr` values. The `color` argument assigns different colors to each of the two lines produced. This call gives us the following plot:

![](SpCond_corrLine.png)

